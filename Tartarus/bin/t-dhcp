#!/usr/bin/python

import sys
import os
import re
from optparse import OptionParser
from functools import wraps

from enum import Enum

from Tartarus.client import initialize
comm, argv = initialize()

from Tartarus.iface import DHCP
from Tartarus.DHCP.iptools import IpAddr

class CommandLineError(Exception):
    def __init__(self, msg):
        super(CommandLineError, self).__init__(msg)

class CommandError(Exception):
    def __init__(self, msg, error_code=1):
        super(CommandError, self).__init__(msg)
        self.error_code = error_code

class Command(object):
    def run(self, argv):
        if len(argv) == 1 and argv[0] == 'help':
            self.help()
            return 0
        try:
            return self.do_cmd(argv)
        except CommandLineError, e:
            print '\033[91mError:\033[0m %s\n' % e
            self.help()
            return 1
        except CommandError, e:
            print '\033[91mError:\033[0m %s\n' % e
            return e.error_code
    @classmethod
    def help(cls):
        name = cls.__name__.lower()
        print 'Usage: %s %s\n' % (sys.argv[0], name)
        print cls.__doc__
        print

def cmd(method):
    @wraps(method)
    def wrapper(self, argv):
        if len(argv) == 1 and argv[0] == 'help':
            self.cmd_help()
            return 0
        try:
            return method(self, argv)
        except CommandLineError, e:
            print '\033[91mError:\033[0m %s\n' % e
            self.cmd_help()
            return 1
        except CommandError, e:
            print '\033[91mError:\033[0m %s\n' % e
            return e.error_code
    wrapper.is_command = True
    return wrapper

class SuperCommand(Command):
    def __init__(self):
        self.__commands = {}
        for i in dir(self):
            attr = getattr(self, i)
            if hasattr(attr, 'is_command') and attr.is_command is True:
                self.__commands[attr.__name__] = attr
    def do_cmd(self, argv):
        if len(argv) < 1:
            raise CommandLineError('you should specify subcommand')
        self.__subcmd = argv[0]
        try:
            callable = getattr(self, self.__subcmd)
            if not callable.is_command:
                raise CommandLineError('command %s not found' % self.__subcmd)
        except:
            raise CommandLineError('command %s not found' % self.__subcmd)
        return callable(argv[1:])
    def cmd_help(self):
        if hasattr(self, 'help_' + self.__subcmd):
            getattr(self, 'help_' + self.__subcmd)()
        else:
            name = type(self).__name__.lower()
            print 'Usage: %s %s %s' % (sys.argv[0], name, self.__subcmd)
            print '\n%s\n' % getattr(self, self.__subcmd).__doc__
    def help(self):
        name = type(self).__name__.lower()
        print 'Usage: %s %s <subcommand> <args>\n' % (sys.argv[0], name)
        print 'Valid subcommands are:'
        for cmd, doc in ((name, attr.__doc__) for name, attr in self.__commands.iteritems()):
            print '  \033[92m%s\033[0m - %s' % (cmd, doc)
        print '\nTry run %s %s <subcommand> help for more information\n' % (sys.argv[0], name)

class Start(Command):
    'start dhcpd daemon'
    def do_cmd(self, argv):
        prx = daemonPrx()
        prx.start()
        return 0

class Stop(Command):
    'stop dhcpd daemon'
    def do_cmd(self, argv):
        prx = daemonPrx()
        prx.stop()
        return 0

class Restart(Command):
    'stop and start dhcpd daemon'
    def do_cmd(self, argv):
        prx = daemonPrx()
        prx.stop()
        prx.start()
        return 0

class Status(Command):
    'show status of dhcpd daemon'
    def do_cmd(self, argv):
        prx = daemonPrx()
        if prx.running():
            print 'DHCP daemon is running'
        else:
            print 'DHCP daemon is not running'

class Reset(Command):
    'reset last changes in configuration'
    def do_cmd(self, argv):
        prx = serverPrx()
        prx.rollback()

class Commit(Command):
    'commit last changes'
    def do_cmd(self, argv):
        prx = serverPrx()
        prx.commit()

class Param(SuperCommand):
    'show, set or unset global parameters'
    @cmd
    def show(self, argv):
        'show parameters'
        if len(argv) != 1: raise CommandLineError('wrong parameters')
        scope = argv[0]
        if scope == 'global':
            srv = serverPrx()
            for i in srv.params().iteritems():
                print '%s: %s' % i
            return 0
        if re.match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}', scope):
            srv = serverPrx()
            s = srv.findSubnet(scope)
            if s is None: raise CommandError('subnet %s is not found' % scope)
            for i in s.params().iteritems():
                print '%s: %s' % i
            return 0
        srv = serverPrx()
        h = srv.hostsByNames([scope])[0]
        if h is None: raise CommandError('host %s is not found' % scope)
        for i in h.params().iteritems():
            print '%s: %s' % i
        return 0
    def help_show(self):
        print 'Usage: %s param show <scope>' % sys.argv[0]
        print '\nShow parameters for scope'
        print '<scope> can be "global", subnet in form <ip-addr>/<mask> or host name\n'
    @cmd
    def set(self, argv):
        'set parameter'
        if len(argv) != 3: raise CommandLineError('wrong parameters')
        scope, key, value = argv
        if scope == 'global':
            srv = serverPrx()
            srv.setParam(key, value)
            return 0
        if re.match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}', scope):
            srv = serverPrx()
            s = srv.findSubnet(scope)
            if s is None: raise CommandError('subnet %s is not found' % scope)
            s.setParam(key, value)
            return 0
        srv = serverPrx()
        h = srv.hostsByNames([scope])[0]
        if h is None: raise CommandError('host %s is not found' % scope)
        h.setParam(key, value)
        return 0
    def help_set(self):
        print 'Usage: %s param set <scope> <param> <value>' % sys.argv[0]
        print '\nSet <param> to <value> for scope <scope>'
        print '<scope> can be "global", subnet in form <ip-addr>/<mask> or host name\n'
    @cmd
    def unset(self, argv):
        'unset parameters'
        if len(argv) != 2: raise CommandLineError('wrong parameters')
        scope, key = argv
        if scope == 'global':
            srv = serverPrx()
            srv.unsetParam(key)
            return 0
        if re.match('^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}', scope):
            srv = serverPrx()
            s = srv.findSubnet(scope)
            if s is None: raise CommandError('subnet %s is not found' % scope)
            s.unsetParam(key)
            return 0
        srv.serverPrx()
        h = srv.hostsByNames([scope])[0]
        if h is None: raise CommandError('host %s is not found' % scope)
        h.unsetParam(key)
        return 0

class Subnet(SuperCommand):
    'list, create or delete subnets'
    @cmd
    def add(self, argv):
        'add subnet'
        if len(argv) != 1:
            raise CommandLineError('wrong number of arguments')
        prx = serverPrx()
        prx.addSubnet(argv[0])
    def help_add(self):
        print 'Usage: %s subnet add <decl>' % sys.argv[0]
        print '\nAdd subnet. <decl> should be in CIDR form: <ip-addr>/<mask>\n'
    @cmd
    def list(self, argv):
        'list all available subnets'
        prx = serverPrx()
        for s in prx.subnets():
            print '%s:' % s.decl()
            for r in s.ranges():
                start, end = r.addrs()
                print '%s-%s: %s' % (start, end, 'not realised')
    @cmd
    def delete(self, argv):
        'delete subnet'
        if len(argv) != 1:
            raise CommandLineError('wrong number of arguments')
        srv = serverPrx()
        s = srv.findSubnet(argv[0])
        if s is None: raise CommandError('subnet %s is not found' % argv[0])
        srv.delSubnet(s)
    def help_delete(self):
        print 'Usage: %s subnet delete <decl>' % sys.argv[0]
        print '\nDelete subnet. <decl> should be in CIDR form: <ip-addr>/<mask>\n'

class Range(Command):
    Action = Enum('LIST', 'ADD', 'REMOVE', 'MODIFY')
    def __init__(self):
        usage = (
                'Usage: %(prog)s range [<addr>]|[<addr>/<mask>] [-o]   - list mode\n'
                '       %(prog)s range -a <start> <end> <caps>         - add mode\n'
                '       %(prog)s range -r <addr>                       - remove mode\n'
                '       %(prog)s range -m <addr> <caps>                - modify mode'
                )
        self.optp = OptionParser(usage=usage % { 'prog': sys.argv[0] })
        opt = self.optp.add_option
        Action = self.Action
        opt('-a', '--add',
                action='store_const', dest='action', const=Action.ADD,
                help='Create new range')
        opt('-r', '--remove',
                action='store_const', dest='action', const=Action.REMOVE,
                help='Remove range')
        opt('-m', '--modify',
                action='store_const', dest='action', const=Action.MODIFY,
                help='Modify range capabilities')
        opt('-o', '--show-options',
                action='store_true',
                help='Show range options (only for list mode)')
        self.optp.set_defaults(action=Action.LIST)
    def do_cmd(self, args):
        Action = self.Action
        opts, args = self.optp.parse_args(args)
        {
                Action.LIST: self.do_list,
                Action.ADD: self.do_add,
                Action.REMOVE: self.do_remove,
                Action.MODIFY: self.do_modify
        }[opts.action](opts, args)
    @classmethod
    def do_list(cls, opts, args):
        srv = serverPrx()
        if len(args) == 0:
            for s in srv.subnets():
                ranges = [(IpAddr(r.addrs()[0]).int, r) for r in s.ranges()]
                ranges.sort(key=lambda r: r[0])
                for r in (r[1] for r in ranges):
                    cls.printRange(r, opts.show_options, s)
        elif len(args) == 1:
            if '/' in args[0]:
                s = srv.findSubnet(args[0].split('/')[0])
                if not s: return
                ranges = [(IpAddr(r.addrs()[0]).int, r) for r in s.ranges()]
                ranges.sort(key=lambda r: r[0])
                for r in (r[1] for r in ranges):
                    cls.printRange(r, opts.show_options, s)
            else:
                r = srv.findRange(args[0])
                if not r: return
                cls.printRange(r, opts.show_options)
    @classmethod
    def printRange(cls, range, options=False, subnet=None):
        start, end = range.addrs()
        if not subnet:
            srv = serverPrx()
            subnet = srv.findSubnet(start)
        caps = range.caps()
        caps_str = ''
        if caps & DHCP.STATIC: caps_str += 's'
        if caps & DHCP.KNOWN: caps_str += 'k'
        if caps & DHCP.UNKNOWN: caps_str += 'u'
        print '%s-%s (%s) CAPS: %s' % (start, end, subnet.cidr(), caps_str)
        if options:
            for o in range.options().iteritems():
                print '  %s: %s' % o
    @classmethod
    def do_add(cls, opts, args):
        if len(args) != 3: raise RuntimeError('Wrong arguments')
        start, end, caps = args
        c = 0
        if 's' in caps: c |= DHCP.STATIC
        if 'k' in caps: c |= DHCP.KNOWN
        if 'u' in caps: c |= DHCP.UNKNOWN
        srv = serverPrx()
        s = srv.findSubnet(start)
        if not s: raise RuntimeError('Can\'t find subnet for new range')
        s.addRange(start, end, c)
    @classmethod
    def do_remove(cls, opts, args):
        if len(args) != 1: raise RuntimeError('Wrong arguments')
        srv = serverPrx()
        r = srv.findRange(args[0])
        if not r: raise RuntimeError('Can\'t find range')
        s = srv.findSubnet(args[0])
        s.delRange(r.id())
    @classmethod
    def do_modify(cls, opts, args):
        if len(args) != 2: raise RuntimeError('Wrong arguments')
        addr, caps = args
        c = 0
        if 's' in caps: c |= DHCP.STATIC
        if 'k' in caps: c |= DHCP.KNOWN
        if 'u' in caps: c |= DHCP.UNKNOWN
        srv = serverPrx()
        r = srv.findRange(addr)
        if not r: raise RuntimeError('Can\'t find range')
        r.setCaps(c)

class Host(Command):
    Action = Enum('LIST', 'ADD', 'REMOVE')
    def __init__(self):
        usage = (
                'Usage: %(prog)s host [<identity>]|[<hardware>] [-o]       - list mode\n'
                '       %(prog)s host -a <name> <id>|ethernet <mac-addr>   - add mode\n'
                '       %(prog)s host -r <addr>                            - remove mode\n'
                )
        self.optp = OptionParser(usage=usage % { 'prog': sys.argv[0] })
        opt = self.optp.add_option
        Action = self.Action
        opt('-a', '--add',
                action='store_const', dest='action', const=Action.ADD,
                help='Create new range')
        opt('-r', '--remove',
                action='store_const', dest='action', const=Action.REMOVE,
                help='Remove range')
        opt('-o', '--show-options',
                action='store_true',
                help='Show range options (only for list mode)')
        self.optp.set_defaults(action=Action.LIST)
    def do_cmd(self, args):
        Action = self.Action
        opts, args = self.optp.parse_args(args)
        {
                Action.LIST: self.do_list,
                Action.ADD: self.do_add,
                Action.REMOVE: self.do_remove,
        }[opts.action](opts, args)
    @classmethod
    def do_list(cls, opts, args):
        srv = serverPrx()
        if len(args) != 0: RuntimeError('Wrong arguments')
        for h in srv.hosts():
            cls.printHost(h, opts.show_options)
    @classmethod
    def printHost(cls, host, options=False):
        name = host.name()
        id = host.id()
        if id.type == DHCP.HostIdType.IDENTITY:
            str_id = 'id: %s' % id.value
        else:
            str_id = 'hw: %s' % id.value
        print '%s(%s)' % (name, str_id)
        if not options: return
        for i in host.params():
            print '  %s: %s' % i
    @classmethod
    def do_add(cls, opts, args):
        if len(args) == 2:
            id = DHCP.HostId(DHCP.HostIdType.IDENTITY, args[1])
        elif len(args) == 3 and args[1] == 'ethernet':
            id = DHCP.HostId(DHCP.HostIdType.HARDWARE, 'ethernet '+args[1])
        else: raise RuntimeError('Wrong arguments')
        srv = serverPrx()
        srv.addHost(args[0], id)
    @classmethod
    def do_remove(cls, opts, args):
        if len(args) != 1: raise RuntimeError('Wrong arguments')
        srv = serverPrx()
        srv.delHost(args[0])

class Main:
    def __init__(self, argv):
        self.__exec_name = sys.argv[0]
        self.__argv = argv
        self.__cmds = {}
        for cmd, cls in ((cmd.lower(), cls) for cmd, cls in globals().iteritems() if
                isinstance(cls, type)
                and issubclass(cls, Command)
                and cls not in (Command, SuperCommand)
                ):
            self.__cmds[cmd] = cls
    def usage(self):
        print 'Usage: %s <command> <args>\n' % sys.argv[0]
        self.helpCmds()
    def helpCmds(self):
        print 'Valid commands are:'
        for cmd, doc in ((key, cmd.__doc__) for key, cmd in self.__cmds.iteritems()):
            print '  \033[92m%s\033[0m - %s' % (cmd, doc)
        print '\nTry run %s <command> help for more information\n' % sys.argv[0]
    def __call__(self):
        if len(self.__argv) < 2:
            self.usage()
            return 1
        cmd = self.__argv[1]
        cmd = self.__cmds.get(cmd, None)
        if cmd is None:
            print 'Error: %s - unknown command' % self.__argv[1]
            self.helpCmds()
            return 1
        argv = self.__argv[2:]
        cmd().run(argv)
        comm.destroy()
        return 0

def daemonPrx():
    prx = comm.stringToProxy('DHCP/Daemon')
    return DHCP.DaemonPrx.checkedCast(prx)

def serverPrx():
    prx = comm.stringToProxy('DHCP/Server')
    return DHCP.ServerPrx.checkedCast(prx)

sys.exit(Main(argv)())

